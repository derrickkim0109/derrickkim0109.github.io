---
title: 보수의 개념 (Complement)
author: Derrick Kim
description: 본 내용은 CS지식을 쌓기 위해 내가 공부한 내용을 기록하기 위해 사용.
categories: [computer_science]
tags: [computer_science, complement]
date: "2022-04-08T 09:39:33.284Z"
--- 
해당 내용은 [대멀쌤](https://www.youtube.com/channel/UCcF8jrcE2KhrbI8wPrnMcYA)의 유튜브를 통해서 공부한 내용입니다. 설명이 굉장히 자세히 나와 있으니 꼭꼭 보길 추천!
  
  저의 미숙함으로 인해 틀린 부분이 있을 수 있는 점 양해 바랍니다. 
  
---
# 보수 (Complement)

```
연산
├── 2 진수
│   
└── 가산기
```
- + 
-  - : 보수 <- 뺄셈을 덧셈으로 해결
-  x : +++
-  / : ---

> 보수를 잘 이해 하면 가산기로 사칙연산이 가능하다.

#### 뺄셈을 가산기(덧셈)으로 풀기
ex) 9 - 6 = 3

9 + ◻ = 3

◻ : '-6'에 대한 보수

```

| ─ | ─ | ─ | ─ | ─ | ─ | ─ | ─ | ─ | ─ | ─ | ─ | 
-6   					0				        6

```

10진수로 보면 -6에서 10칸 가봐라 --> 4까지 간다

- 4 는 '-6'의 보수이다.

==> 9 + 4 = 13

13중에 3만 출력하는 것이다.

---
# 1의 보수 (4Bit)

> 1의 보수를 사용하기 위해서는 10진수를 2진수로 변환해야 한다. 

EX) 십진수 10(양수) 있다고 가정 할 경우

-  양수는 보수를 취하지 않으니까 마이너스(-)를 붙여서 음수로 만든다. 

```
10 = 1010(2) <- 양수
	| | | |   <- XOR 1111
	0101   <- 음수 10 ( 1의 보수)
```
> XOR : 두개의 입력이 같을때 0, 두개의 입력이 다를 때 1

EX) 13 - 10 = 3

- 8421   
- 13 = 1101(2)
- 10 = 1010(2)
- 3 = 0011(2)
- (-10) = 0101(2)

```
	   1101
	+  0101   
	--------
	  10010 -> 우리는 4bit 만 필요하여
	   최상위 Bit 1을 최하위 비트에 더해 주는 것
	   ==> 1의 보수 
	   
	  0010 
	+    1   
	--------
	  0011
```

EX) 10 - 13 = -3

- 10101 - 1101 = -0011
- 10 = 1010(2)
- 13 = 1101(2)
	- (-13) = 0010(2)
- (3) = 0011(2)
	- (-3) = 1100(2)

```
	   1010
	+  0010   
	--------
	   1100  <- * 캐리 비트가 발생하지 않음.
	--------  < 다시 한 번 1의 보수를 취해 줘야함.
	  -0011
```

---
# 2의 보수
> 십진수 (-10)

```
	  -1010(2) 
	--------
	   0101  <- 1의 보수
	  +   1
	--------  < 1의 보수에 + 1을 해주면 2의 보수가 됨
	  0110 < - 2의 보수
```

EX) 13 - 10 = 3

- 1101 - 1010 = 0011
- (-10) 1의 보수 = 0101
- 0101 을 2의 보수는 + 1 을 더한다
- 0110

```
	   1101 
	 + 0110
	--------
	  10011 <- 2의 보수는 1(캐리)을 버린다
	  => 0011 최종값.
```

EX) 10 - 13 = -3

- 10101 - 1101 = -0011

- 10 = 1010(2)
- 13 = 1101(2)
	- -1101(2)
	- XOR = 0010
	- 2의 보수는 0011

```
	   1010
	+  0011   
	--------
	   1101  <- * 캐리 비트가 발생하지 않음.
	--------  < 2의 보수를 사용했기 때문에 2의보수 다시
	   0010
	   +  1
	 --------
	  -0011
```

---
# 보수에 대한 착각 4가지 
> 부호를 포함한 3비트 표

```
부호와 절대치.            1의 보수		2의 보수
+0	0 0 0	- >    	000		- >    	000
+1	0 0 1	- >    	001		- >    	000
+2	0 1 0	- >    	010		- >    	010
+3	0 1 1 	- >    	011		- >    	011
-0	1 0 0	- >    	111		- >    	000
-1	1 0 1		- >    	110		- >    	111
-2	1 1 0		- >    	101		- >    	110
-3	1 1 1	 	- >    	100		- >    	101

```

1. 양수에 대한 보수 처리 -> 하지 않는다!
2. 가중치 ? - 보수 처리된 숫자는 가중치를 가지고 있지 않다
3. +0, -0이 공존
4. 연산 결과가 음수 일떄? <- 1의 보수 부분에 있음



